## golang简介

## 默认规则
- 所有以大写字母开头变量, 函数, 结构体, 结构体中的成员, 数组...等等类型,都可以被其他包引用访问
- 变量,包名都是区分大小写的, 包的路径根据系统不同来确定是否区分大小写.推荐所有包的目录名都小写.

## 数据类型
- 基础类型 : 整形, 浮点, 复数, 布尔, 字符串
- 复合类型 : 数组, 结构体, Slice, Map

## 常量
- 常量类型都是基础类型, 布尔, 数字, 字符串
- 数字型的常量没有大小和符号, 可以是任何精度而不会产生溢出
- 常量的值必须能够在编译期间确定, 可以使用表达式计算其值, 但所有用于计算的值必须能在编译期间确定.
- 常量的定义可以分为无类型定义和有类型定义,无类型的常量会在使用的地方根据上下文确定其类型, 或者在定义的时候根据赋值确定其类型

## 变量
- 方式1 : `var 变量名 类型` 对于没有赋值的变量, 编译器会根据类型默认初始化"0"值
- 方式2 : `var 变量名 = 表达式` 如果申明的时候同时赋值, 可以省略类型, 编译器可以通过推断表达式的类型来设置变量类型
- 方式3 : `var 变量名1, 变量名n 类型` 申明一组同类型的变量
- 方式4 : `var 变量1, 变量2, 变量3 = 类型1, 类型2, 类型3` 也可以加上圆括号通过换行的方式写 `var ()`
- 简短方式1 : `变量名 := 表达式` 这种申明方式只能用于函数内部, 而且变量必须是之前未申明过的对象.
- 简短方式2 : `变量1, 变量2 := 表达式1, 表达式2` 组申明的方式中, 变量1和变量2中至少有一个是之前未声明过的

## nil和各种类型的零值
- nil是预定义的标识符，代表指针、通道、函数、接口、映射或切片的零值，也就是预定义好的一个变量
- 类型的零值是指, 变量定义后没有赋值就直接使用, 这时编译器会给他设置一个默认的初始值, 并不是值他的值为零.
```golang
bool      -> false                              
numbers -> 0                                 
string    -> ""      

pointers -> nil
slices -> nil
maps -> nil
channels -> nil
functions -> nil
interfaces -> nil
```

## 值类型和隐式指针类型(引用类型)
- 这里用隐式指针类型更好理解, 一般情况都是值传递的方式, 如果我们想共享一个数据的时候, 我们会使用指针.
- Map,slice,chan,interface,func 这些类型是隐式指针类型, 其他的类型都是值类型, 包括结构体和数组
- 函数的参数都是值传递的方式, 对于隐式指针类型的参数传递, 也是对指针的复制

## 结构体, MAP, 数组, 切片
- 他们都是复合类型
- 结构体必须先定义, 然后才能用定义的结构体类型去创建变量, MAP,数组,切片也需要先定义类型,只是定义类型的同时就可以用定义的类型创建变量   
```golang
type Mystruct struct{}
var mystruct Mystruct

var mymay map[string]int
var myarray [3]int
var myslice []int
```
- 结构体, MAP, 数组, 切片因为成员类型或数量的不同而变为不同的类型, 比如数组[2]int和[3]int是两个不同类型的数组,其他的三个也同理

## 切片--slice
- 切片的创建分为, 直接创建 和 基于数组创建两种方式.
- 基于数组创建时,需要标明基于数组的起始索引和结束索引,切片的长度等于结束索引减去开始索引, 容量等于数组最后一位的索引减去切片开始的索引
- 直接创建时,需要标明切片的长度和容量,这个和基于数组创建的方式不一样.

## type--类型定义
- 定义MAP
``` go
    //定义 
    var map1 map[string]string
    //创建
    map1 = map[string]string{}
    //或者把上面两步和成一步
    map2 := map[string]string{}
    //定义的时候同时赋值
    map3 := map[string]string{
        "A":"a",
        "B":"b",
    }
```
- 定义结构体
``` go
    //定义结构体
    type Stu struct{
        Name string
    }
    //定义结构体变量
    var stu Stu
    //给结构体变量赋值
    stu = Stu{}
    //匿名结构体
    st := struct{Name string}{"Tome"}
```
- 封装基本类型
- 定义接口
``` golang
    //定义一个接口类型的变量
    var myi interface{}
    //定义一个接口类型
    type myi interface{}
```
- 定义函数类型
``` go
    //定义一个函数类型
    type ft func(string)string
    //定义一个函数类型的变量, 初始值为nil
    var f func(int, string) string
```

## 指针, uintptr 和 unsafe包
- 每个变量都在内存中有个内存地址
- 指针也是变量, 指针存储的是指向某个内存的地址, 指针的类型总是和他指向内存的地址中存储的值的类型相关
- 指针是存放着某种类型数据的内存地址的变量
- 通过var关键字声明的指针(`var 变量名 *类型`), 默认的地址为(0x0, 是一个无效内存地址), 这时不能进行取值运算(*变量名), 通过new函数创建的指针可以直接进行取值运算
- go中的指针(*类型)不能进行指针运算, 只能传递地址
- unsafe.Pointer 通用指针类型，用于转换不同类型的指针，不能进行指针运算
- uintptr 相当于一个无符号整形, 可以用于计算
- 任何类型的指针值都可以转换为unsafe.Pointe, 反之亦然
- uintptr可以转换为unsafe.Pointer, 反之亦然

## 接口
- 

## 类型转换和断言
- 所有的类型必须显示转换
- 类型转的格式 : <结果类型> := <目标类型> ( <表达式> )
- 断言也是类型转换, 但主要用于接口
- 断言的格式1 : <目标类型的值>，<布尔参数> := <表达式>.( 目标类型 )     // 安全类型断言
- 断言的格式2 : <目标类型的值> := <表达式>.( 目标类型 )     //非安全类型断言

## 类型转换示例
- string转int  `strconv.Atoi(string)`
- int转string `strconv.Itoa(int)`
- string转[]byte `[]byte(string)`
- []byte转string `string([]byte)`
- string转[]rune `[]rune(string)`
- []rune转string `string([]rune)`


## 别名定义



## 包
- go的包层级结构和开发环境的目录结构一致, 这点和java是一样的.
- 包名和所在目录的目录名一致(推荐), 当然也可以不一致.但一个目录下面的所有.go文件的包名必须都一样.
- 在包的引入的时候,只用引入包所在目录的目录路径, 而不用引入包名, 在使用包里面的函数的时候需要带上包名, 如 包名.函数名
- 包名是区分大小写的, 推荐包名小写
- 每个go的源文件都是以package语句开头的

## make & new
- make只能用来分配及初始化类型为slice，map，chan的数据；new可以分配任意类型的数据
- new返回的是指针，即*T, 指针指向该类型的新分配的零值；make返回的是slice, map, chan类型中的一种的类型引用，即T, 具体的类型由make参数决定, 会类型引用初始化对应的零值；

## 结构体标签
```go
type T2 struct {
	Name string `json:"name"`
	Age  int    `json:"age"`
}
```
- `json:"name"` 这个就是结构体标签

## 单引号 双引号 反引号
- 单引号 : 用于单个字符, go使用的UTF-8的编码,单个字符的大小是1-4个字节.所以需要注意变量的容量, 一般用rune存储单个字符.
- 双引号 : 用来创建可解析的字符串字面量(支持转义, 但不能用来引用多行). go中字符串使用的是UTF-8的编码.
- 反引号 : 用来创建原生的字符串字面量(不支持任何转义, 可以由多行组成)


## 临时的东西 , 需要验证其正确性
- 